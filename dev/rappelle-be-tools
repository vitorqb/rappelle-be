#!/usr/bin/python3

import argparse
import subprocess
import os
import json


# Globals
# (some day should be converted to configurable options)
DB_NAME = "rappelle-be"
TEST_DB_NAME = "rappelle-be-test"
POSTGRES_USER = "theuser"
PROJECT_NAME = "rappelle-be"


# Helpers
class Runner():
    """ A configurable runner for commands """

    def __init__(self, cwd, docker_compose_cmd):
        self.cwd = cwd
        self.deploy_dir = f"{cwd}/deploy"
        self.docker_compose_cmd = docker_compose_cmd

    def run(self, args, cwd=None):
        cwd = cwd or self.cwd
        print(f"Running {args} in {cwd}")
        subprocess.run(args, cwd=cwd, check=True)

    def run_docker_compose(self, args):
        cmd = [
            *self.docker_compose_cmd,
            f"-p{PROJECT_NAME}",
            "-fdocker-compose.yaml",
            "-fdocker-compose.local.yaml",
            "-fdocker-compose.dev.yaml"
        ]
        self.run([*cmd, *args], self.deploy_dir)

    def run_sbt(self, args):
        cmd = ["coursier", "launch", "sbt", "--"]
        self.run([*cmd, *args], self.cwd)


# Bootstrap
def bootstrap(args):

    if not os.path.exists(f"{args.directory}/conf/application.dev.conf"):
        print(f"BOOTSTRAP: Creating {args.directory}/conf/application.dev.conf")
        with open(f"{args.directory}/conf/application.dev.conf", "wb") as f:
            f.write(b"include \"application.local\"")

    if not os.path.exists(f"{args.directory}/conf/application.funTest.conf"):
        print(f"BOOTSTRAP: Creating {args.directory}/conf/application.funTest.conf")
        with open(f"{args.directory}/conf/application.funTest.conf", "wb") as f:
            f.write(b"include \"application.local\"")

    if not os.path.exists(f"{args.directory}/deploy/docker-compose.dev.yaml"):
        print(f"BOOTSTRAP: Creating {args.directory}/deploy/docker-compose.dev.yaml")
        with open(f"{args.directory}/deploy/docker-compose.dev.yaml", "wb") as f:
            f.write(b"version: \"3.7\"")


# Commands
def scalafmt(r, args):
    cmd = ['coursier', 'launch', 'scalafmt', '--']
    if args.check:
        cmd += ['--check']
    cmd += ["--debug", './app', './test']
    r.run(cmd)


def sbt(r, args):
    cmd = []
    if args.no_supershell:
        cmd += ['--supershell=false']
    r.run_sbt(cmd)


def test(r, args):
    context = ('FunTest' if args.functional else 'Test')
    subCmd = f"{context} / testOnly"
    if args.pattern and args.pattern != "":
        subCmd += f" {args.pattern}"
    r.run_sbt([subCmd])


def postgres(r, args):
    cmd = ['up', '--force-recreate']
    if args.detach:
        cmd += ["--detach"]
    cmd += ['postgres']
    r.run_docker_compose(cmd)


def wait_for_postgres(r, args):
    cmd = [
        "exec",
        "postgres",
        "bash",
        "-c",
        "until pg_isready; do sleep 2; done"
    ]
    r.run_docker_compose(cmd)


def postgres_shell(r, args):
    db = (TEST_DB_NAME if args.test else DB_NAME)
    r.run_docker_compose(['exec', 'postgres', 'psql', db, POSTGRES_USER])


def docker_compose(r, args):
    cmd = args.command
    r.run_docker_compose(cmd)


def run(r, args):
    cmd = "run -Dconfig.resource=application.dev.conf"
    if args.port:
        cmd += f" {args.port}"
    r.run_sbt([cmd])


def curl(r, args):
    url = f"127.0.0.1:9000{args.command[-1]}"
    cmd = [
        "curl",
        "-H",
        "Authorization: Bearer faketoken",
        "-H",
        "Content-Type: application/json",
        *args.command[:-1],
        url
    ]
    r.run(cmd)


# Arg parsing
parser = argparse.ArgumentParser(description="Development tools for rappelle-be")
parser.add_argument(
    "-D",
    "--directory",
    help="the directory with the github repo root",
    default=os.environ.get("RAPPELLE_BE_REPO_ROOT", "~/git/rappelle-be")
)
parser.add_argument(
    "--docker-compose-cmd",
    help="shell command to use to run docker-compose. Must be a valid json array.",
    default=os.environ.get("RAPPELLE_BE_DOCKER_COMPOSE_CMD", "[\"docker-compose\"]")
)
subparsers = parser.add_subparsers()

parser_scalafmt = subparsers.add_parser('scalafmt')
parser_scalafmt.set_defaults(func=scalafmt)
parser_scalafmt.add_argument("-c", "--check", action="store_true", help="Check if formatted instead of fix")

parser_sbt = subparsers.add_parser('sbt')
parser_sbt.set_defaults(func=sbt)
parser_sbt.add_argument("--no-supershell", dest="no_supershell", action="store_true")

parser_postgres = subparsers.add_parser('postgres')
parser_postgres.set_defaults(func=postgres)
parser_postgres.add_argument("-d", "--detach", help="Detaches after running", action="store_true")

parser_test = subparsers.add_parser('test')
parser_test.set_defaults(func=test)
parser_test.add_argument("-f", "--functional", dest="functional", action="store_true", help="Run functional tests instead")
parser_test.add_argument("-p", "--pattern", help="Test pattern to pass to sbt (e.g. **MyCoolSpec)")

parser_postgres_shell = subparsers.add_parser('postgres-shell')
parser_postgres_shell.set_defaults(func=postgres_shell)
parser_postgres_shell.add_argument("-t", "--test", help="Connect to test db instead.", action="store_true")

parser_wait_for_postgres = subparsers.add_parser('wait-for-postgres')
parser_wait_for_postgres.set_defaults(func=wait_for_postgres)

parser_docker_compose = subparsers.add_parser('docker-compose')
parser_docker_compose.set_defaults(func=docker_compose)
parser_docker_compose.add_argument('command', nargs='+', help="Runs command in docker-compose")

parser_run = subparsers.add_parser('run')
parser_run.set_defaults(func=run)
parser_run.add_argument('-p', '--port')

parser_curl = subparsers.add_parser('curl')
parser_curl.set_defaults(func=curl)
parser_curl.add_argument('command', nargs='+', help="Runs curl with custom headers. Assumes the relative url is the last param.")


# Script
if __name__ == "__main__":
    args = parser.parse_args()
    bootstrap(args)
    docker_compose_cmd = json.loads(args.docker_compose_cmd)
    runner = Runner(cwd=args.directory, docker_compose_cmd=docker_compose_cmd)
    args.func(runner, args)
