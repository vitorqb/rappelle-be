#!/usr/bin/python3

import argparse
import subprocess
import os
import json


# Globals
# (some day should be converted to configurable options)
DB_NAME = "rappelle-be"
TEST_DB_NAME = "rappelle-be-test"
POSTGRES_USER = "theuser"
PROJECT_NAME = "rappelle-be"


# Helpers
class Runner():
    """ A configurable runner for commands """

    def __init__(self, cwd, docker_compose_cmd, docker_cmd):
        self.cwd = cwd
        self.deploy_dir = f"{cwd}/deploy"
        self.docker_compose_cmd = docker_compose_cmd
        self.docker_cmd = docker_cmd

    def run(self, args, cwd=None):
        cwd = cwd or self.cwd
        print(f"Running {args} in {cwd}")
        subprocess.run(args, cwd=cwd, check=True)

    def check_output(self, args, cwd=None):
        cwd = cwd or self.cwd
        print(f"Checking output of {args} in {cwd}")
        return subprocess.check_output(args, cwd=cwd)

    def run_docker_compose(self, args):
        cmd = [
            *self.docker_compose_cmd,
            f"-p{PROJECT_NAME}",
            "-fdocker-compose.yaml",
            "-fdocker-compose.local.yaml",
            "-fdocker-compose.dev.yaml"
        ]
        self.run([*cmd, *args], self.deploy_dir)

    def run_docker(self, args, **kwargs):
        self.run([*self.docker_cmd, *args], **kwargs)

    def run_sbt(self, args, cwd=None):
        cwd = cwd or self.cwd
        cmd = ["coursier", "launch", "sbt", "--"]
        self.run([*cmd, *args], cwd)


# Bootstrap
def bootstrap(args):

    if not os.path.exists(f"{args.directory}/conf/application.dev.conf"):
        print(f"BOOTSTRAP: Creating {args.directory}/conf/application.dev.conf")
        with open(f"{args.directory}/conf/application.dev.conf", "wb") as f:
            f.write(b"include \"application.local\"")

    if not os.path.exists(f"{args.directory}/conf/application.funTest.conf"):
        print(f"BOOTSTRAP: Creating {args.directory}/conf/application.funTest.conf")
        with open(f"{args.directory}/conf/application.funTest.conf", "wb") as f:
            f.write(b"include \"application.local\"")

    if not os.path.exists(f"{args.directory}/deploy/docker-compose.dev.yaml"):
        print(f"BOOTSTRAP: Creating {args.directory}/deploy/docker-compose.dev.yaml")
        with open(f"{args.directory}/deploy/docker-compose.dev.yaml", "wb") as f:
            f.write(b"version: \"3.7\"")


# Commands
def scalafmt(r, args):
    cmd = ['coursier', 'launch', 'scalafmt', '--']
    if args.check:
        cmd += ['--check']
    cmd += ["--debug", './app', './test']
    r.run(cmd)


def sbt(r, args):
    cmd = []
    if args.no_supershell:
        cmd += ['-Dsbt.supershell=false']
    r.run_sbt(cmd)


def test(r, args):
    if args.functional:
        context = 'FunTest'
    elif args.all:
        context = 'AllTests'
    else:
        context = 'Test'
    subCmd = f"{context} / testOnly"
    if args.pattern and args.pattern != "":
        subCmd += f" {args.pattern}"
    r.run_sbt([subCmd])


def postgres(r, args):
    cmd = ['up', '--force-recreate']
    if args.detach:
        cmd += ["--detach"]
    cmd += ['postgres']
    r.run_docker_compose(cmd)


def wait_for_postgres(r, args):
    cmd = [
        "exec",
        "postgres",
        "bash",
        "-c",
        "until pg_isready; do sleep 2; done"
    ]
    r.run_docker_compose(cmd)


def postgres_shell(r, args):
    db = (TEST_DB_NAME if args.test else DB_NAME)
    r.run_docker_compose(['exec', 'postgres', 'psql', db, POSTGRES_USER])


def docker_compose(r, args):
    cmd = args.command
    r.run_docker_compose(cmd)


def run(r, args):
    cmd = "run -Dconfig.resource=application.dev.conf"
    if args.port:
        cmd += f" {args.port}"
    r.run_sbt([cmd])


def curl(r, args):
    url = f"127.0.0.1:9000{args.command[-1]}"
    cmd = [
        "curl",
        "-H",
        "Content-Type: application/json",
        *args.command[:-1],
        url
    ]
    r.run(cmd)


def build(r, args):

    # Preparation
    source_files = ["app", "build.sbt", "conf", "project"]
    app_version = r.check_output(["git", "describe", "--tags"]).decode().strip()
    tag = args.tag or f"rappelle-be:{app_version}"
    build_dir = args.build_dir
    if not os.path.isabs(build_dir):
        build_dir = f"{args.directory}/{args.build_dir}"

    # Clean
    r.run(["rm", "-rf", build_dir])

    # Prepares build directory
    r.run(["mkdir", build_dir])
    for f in source_files:
        r.run(["cp", "-r", f, f"{build_dir}/{f}"])
    for f in os.listdir(f"{args.directory}/docker"):
        r.run(["cp", f"{args.directory}/docker/{f}", f"{build_dir}/{f}"])

    # Injects version
    print(f"Injecting application version: {app_version}")
    with open(f"{build_dir}/conf/application.conf", "a") as f:
        f.write("\n")
        f.write("# AUTOMATICALLY INJECTED VERSION\n")
        f.write(f"app.version = {app_version}\n")
        f.write("\n")

    # Compiles
    r.run_sbt(['-Dsbt.supershell=false', 'universal:packageZipTarball'], cwd=build_dir)

    # Builds image
    r.run_docker([
        'build',
        f'--build-arg=APP_VERSION={app_version}',
        f'-t={tag}',
        build_dir
    ])


# Arg parsing
parser = argparse.ArgumentParser(description="Development tools for rappelle-be")
parser.add_argument(
    "-D",
    "--directory",
    help="the directory with the github repo root",
    default=os.environ.get("RAPPELLE_BE_REPO_ROOT", "~/git/rappelle-be")
)
parser.add_argument(
    "--docker-compose-cmd",
    help="shell command to use to run docker-compose. Must be a valid json array.",
    default=os.environ.get("RAPPELLE_BE_DOCKER_COMPOSE_CMD", "[\"docker-compose\"]")
)
parser.add_argument(
    "--docker-cmd",
    help="shell command to use to run docker. Must be a valid json array.",
    default=os.environ.get("RAPPELLE_BE_DOCKER_CMD", "[\"docker\"]")
)
subparsers = parser.add_subparsers()

parser_scalafmt = subparsers.add_parser('scalafmt')
parser_scalafmt.set_defaults(func=scalafmt)
parser_scalafmt.add_argument("-c", "--check", action="store_true", help="Check if formatted instead of fix")

parser_sbt = subparsers.add_parser('sbt')
parser_sbt.set_defaults(func=sbt)
parser_sbt.add_argument("--no-supershell", dest="no_supershell", action="store_true")

parser_postgres = subparsers.add_parser('postgres')
parser_postgres.set_defaults(func=postgres)
parser_postgres.add_argument("-d", "--detach", help="Detaches after running", action="store_true")

parser_test = subparsers.add_parser('test')
parser_test.set_defaults(func=test)
parser_test.add_argument("-f", "--functional", dest="functional", action="store_true", help="Run functional tests instead")
parser_test.add_argument("-p", "--pattern", help="Test pattern to pass to sbt (e.g. **MyCoolSpec)")
parser_test.add_argument("-a", "--all", action="store_true", help="Run all tests. All other args are ignored.")

parser_postgres_shell = subparsers.add_parser('postgres-shell')
parser_postgres_shell.set_defaults(func=postgres_shell)
parser_postgres_shell.add_argument("-t", "--test", help="Connect to test db instead.", action="store_true")

parser_wait_for_postgres = subparsers.add_parser('wait-for-postgres')
parser_wait_for_postgres.set_defaults(func=wait_for_postgres)

parser_docker_compose = subparsers.add_parser('docker-compose')
parser_docker_compose.set_defaults(func=docker_compose)
parser_docker_compose.add_argument('command', nargs='+', help="Runs command in docker-compose")

parser_run = subparsers.add_parser('run')
parser_run.set_defaults(func=run)
parser_run.add_argument('-p', '--port')

parser_build = subparsers.add_parser('build')
parser_build.set_defaults(func=build)
parser_build.add_argument("-d", "--build_dir", help="Build directory", default="target/build")
parser_build.add_argument('-t', '--tag', help="tag for docker file")

parser_curl = subparsers.add_parser('curl')
parser_curl.set_defaults(func=curl)
parser_curl.add_argument('command', nargs='+', help="Runs curl with custom headers. Assumes the relative url is the last param.")


# Script
if __name__ == "__main__":
    args = parser.parse_args()
    bootstrap(args)
    docker_cmd = json.loads(args.docker_cmd)
    docker_compose_cmd = json.loads(args.docker_compose_cmd)
    runner = Runner(cwd=args.directory, docker_compose_cmd=docker_compose_cmd, docker_cmd=docker_cmd)
    args.func(runner, args)
